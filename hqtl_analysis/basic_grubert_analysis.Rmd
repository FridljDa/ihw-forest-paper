---
title: "analyse relationship between p-values and maf"
author: "Danie Fridljand"
date: "08.12.2022"
output: html_document
#header-includes:
#   - \usepackage{bbm}
#vignette: >
#  %\VignetteIndexEntry{"calculate_maf_from_hqtl"}
#  %\VignetteEngine{knitr::rmarkdown}
#  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(tidyr)
library(scales)
library(ggplot2)
library(rtracklayer)
library(here)
library(MatrixEQTL)
library(dplyr)

knitr::opts_chunk$set(echo = TRUE)
options(bitmapType ="cairo")
```

# load data set precalculated p-values

helper function
```{r}
loadRData <- function(fileName){
#loads an RData file, and returns it
    load(fileName)
    get(ls()[ls() != "fileName"])
}
```

## data set 1

The following is the same same data set as in hQTL analysis as in https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12411?af=R, Section 6: APPLICATION EXAMPLE: BIOLOGICAL HIGH-THROUGHPUT DATA. It is taken from [Grubert et al.](https://linkinghub.elsevier.com/retrieve/pii/S0092867415009642). 
```{r}
chr1_full_data_grubert <- loadRData(here("data/hqtl_chrom1_chrom2/snps1.filtered.allGT.txt.rda"))
```

Sample names (The population sample is 76 individuals).
```{r}
MatrixEQTL::colnames(chr1_full_data_grubert)[1:10]
```

SNPs
```{r}
MatrixEQTL::rownames(chr1_full_data_grubert)[1:10]
```

top-left submatrix
```{r}
chr1_full_data_grubert[[1]][1:10,1:10]
```
`0` means no alternative allele, `1` means 1 alternative allele, `2` means 2 alternative allele, 

The p-values are pre-calculated with `MatrixEQTL` package [ref](https://academic.oup.com/bioinformatics/article-lookup/doi/10.1093/bioinformatics/bts163). It is basically row-wise t-test with covariate adjustment. [Here](https://github.com/nignatiadis/IHWpaper/blob/master/inst/real_data_examples/hqtl_example_analysis.R) is the code. The pre-calculated file was. downloaded from [here](https://github.com/nignatiadis/IHWpaper/blob/master/inst/extdata/real_data/hqtl_chrom1_chrom2/chr1_subset.Rds).
```{r}
chr1_pvalues_grubert <- readRDS(here("data/hqtl_chrom1_chrom2/chr1_subset.Rds"))
head(chr1_pvalues_grubert)
```
`SNP`,`gene` are primary keys.
```{r}
chr1_pvalues_grubert %>%
  group_by(SNP,gene) %>%
  filter(n()>1)
```

## data set 2

We consider a second data set
from (Boca and Leek)[https://github.com/SiminaB/Fdr-regression/blob/master/BMI%20GIANT%20meta-analysis/BMI_GIANT_GWAS_results_Scott_theoretical.RData].
```{r}
pvalues_maf_boca <- loadRData(here("data/BMI_GIANT_GWAS.RData"))
head(pvalues_maf_boca)
```

TODO why are there multiple rows per SNP?
```{r, eval = FALSE}
pvalues_maf_boca %>%
  group_by(SNP) %>%
  filter(n()>1)
```
 
## harmonise data set 1 and 2

We calculate the standard deviation for the beta estimate of the effect size from the `beta_se`from `beta` and `tstat`.
```{r}
chr1_pvalues_grubert <- chr1_pvalues_grubert %>%
  mutate(beta_se = beta/tstat,
         tstat = NULL,
         FDR = NULL)
```

We harmonise the two data sets.
```{r}
pvalues_maf_boca <- pvalues_maf_boca %>%
  dplyr::rename(beta = b, beta_se = se, pvalue = p, maf_sample = Freq_MAF_Hapmap) %>%
  mutate(Freq_MAF_Int_Hapmap = NULL,
         A1 = NULL,
         A2 = NULL)

colnames(chr1_pvalues_grubert)
colnames(pvalues_maf_boca)
```
TODO how is Freq_MAF_Hapmap calculated? Is it from sample?

# stratifying pvalues by beta std
```{r}
groups_by_filter <- function(covariate, nbins, ties.method="random", seed=NULL){
  if (!is.null(seed) && ties.method=="random"){
    #http://stackoverflow.com/questions/14324096/setting-seed-locally-not-globally-in-r?rq=1
    tmp <- runif(1)
    old <- .Random.seed
    on.exit( { .Random.seed <<- old } )
    set.seed(as.integer(seed)) 
  }
	rfs <- rank(covariate, ties.method=ties.method)/length(covariate)
	as.factor(ceiling( rfs* nbins))
}
```

## stratifying pvalues by beta std, data set 1

Stratifying the p-values in the first data set by `beta_se` does not really show clear trends.
`mutate(beta_se = beta/tstat)`
```{r}
ggplot(chr1_pvalues_grubert, 
       aes(x = pvalue)) +
  geom_histogram(boundary = 0) +
  facet_wrap(groups_by_filter(chr1_pvalues_grubert$beta_se, 8), nrow = 2)
```

## data set 2

Stratifying the p-values in the second data set by `beta_se` yields very clear trends in the direction we would expect it to.
```{r}
ggplot(pvalues_maf_boca, 
       aes(x = pvalue)) +
  geom_histogram(boundary = 0) +
  facet_wrap(groups_by_filter(pvalues_maf_boca$beta_se, 8), nrow = 2)
```


# compare pvalues and standard deviation of effect size estimate

## data set 1
The following plot makes sense. In `chr1_pvalues_grubert` we have filtered out SNPs with low MAF and high pvalues. 
```{r}
ggplot(chr1_pvalues_grubert,
       aes(x = beta_se , y = pvalue)) +
  scale_fill_gradient(name = "count", trans = "log10")+
  geom_hex()  #bins = 60
```

```{r}
ggplot(chr1_pvalues_grubert,
       aes(x = beta_se , y = pvalue)) +
  scale_y_log10()+
  scale_fill_gradient(name = "count", trans = "log10")+
  geom_hex()  #bins = 60
```

## data set 2

In the data set 2, this plot looks very different.

```{r}
ggplot(pvalues_maf_boca,
       aes(x = beta_se, y =  pvalue)) +
  scale_fill_gradient(name = "count", trans = "log10")+
  geom_hex()  #bins = 60
```
```{r}
ggplot(pvalues_maf_boca,
       aes(x = beta_se, y =  pvalue)) +
  scale_y_log10()+
  scale_fill_gradient(name = "count", trans = "log10")+
  geom_hex()  #bins = 60
```

Reproducing what happens for data set 1.
```{r}
ggplot(pvalues_maf_boca %>%
         filter(pvalue <= 10^(-2), maf_sample >= 0.05),
       aes(x = beta_se, y =  pvalue)) +
  scale_y_log10()+
  scale_fill_gradient(name = "count", trans = "log10")+
  geom_hex()  #bins = 60
```

